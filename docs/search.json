[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R_Guide_notes",
    "section": "",
    "text": "Ces pages sont le résumé des notes prises en explorant l’excellent ouvrage de Joseph Larmarange R-guide. Pour accéder à l’original1, il suffit de cliquer sur son nom ci-dessus.\n1 l’original est toujours mieux que n’importe quelle copie !"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html#bienvenue",
    "href": "index.html#bienvenue",
    "title": "R_Guide_notes",
    "section": "",
    "text": "Ces pages sont le résumé des notes prises en explorant l’excellent ouvrage de Joseph Larmarange R-guide. Pour accéder à l’original1, il suffit de cliquer sur son nom ci-dessus.\n1 l’original est toujours mieux que n’importe quelle copie !"
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "R_Guide_notes",
    "section": "2 Licence",
    "text": "2 Licence\nCe document est mis à disposition selon les mêmes termes que le document original CC BY-NC-SA :\n\nCC : Creative commons\nBY : Attribution, c’est à dire que vous devez citer Joseph LARMARANGE si vous publiez un ou des extraits de son travail\nNC : Non Commercial, c’est à dire que vous n’avez pas le droit de vendre ces publications\nSA : Share sAme conditions, c’est à dire que vous devez publier votre travail sous ces mêmes conditions."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "R_Guide_notes",
    "section": "Notes de bas de page",
    "text": "Notes de bas de page\n\n\nl’original est toujours mieux que n’importe quelle copie !↩︎"
  },
  {
    "objectID": "001_dplyr.html",
    "href": "001_dplyr.html",
    "title": "dplyr",
    "section": "",
    "text": "dplyr facilite le traitement et la manipulation des tableaux de données (qu’il s’agisse de data frame ou de tibble). Il propose une syntaxe claire et cohérente, sous formes de verbes correspondant à des fonctions.\nLes verbes de dplyr prennent en entrée un tableau de données (data frame ou tibble) et renvoient systématiquement un tibble.\nCharger le package :\nlibrary(dplyr, warn.conflicts = FALSE)\nCharger le jeu de données nycflights13, données de tous les vols au départ des aéroports de New-York en \\(2013\\), répartis en \\(3\\) tables1 :\nCharger le package :\nlibrary(nycflights13)\nCharger les tables :\ndata(flights)\ndata(airports)\ndata(airlines)"
  },
  {
    "objectID": "001_dplyr.html#opérations-sur-les-lignes",
    "href": "001_dplyr.html#opérations-sur-les-lignes",
    "title": "dplyr",
    "section": "Opérations sur les lignes",
    "text": "Opérations sur les lignes\n\nfilter()\nfilter() des lignes d’une table selon une condition passée en paramètre.\nSeules les lignes pour lesquelles le test renvoie TRUE sont renvoyées2.\n2 une ligne pour laquelle le test renvoie FALSE (faux) ou NA, d’est à dire non avable (valeur manquante) sera ignorée, donc pas renvoyée3 variable monthSélection des vols du mois de janvier3 :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOu plus simplement avec un pipe :\n\nflights |&gt; \n  filter(month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSélectionner les vols avec un retard au départ4 entre 10 et 15 minutes :\n4 variable dep_delay\nflights |&gt; \n  filter(dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nTester avec une fonction. Les vols avec la plus grande distance :\n\nflights |&gt; \n  filter(distance == max(distance))\n\n# A tibble: 342 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      857            900        -3     1516           1530\n 2  2013     1     2      909            900         9     1525           1530\n 3  2013     1     3      914            900        14     1504           1530\n 4  2013     1     4      900            900         0     1516           1530\n 5  2013     1     5      858            900        -2     1519           1530\n 6  2013     1     6     1019            900        79     1558           1530\n 7  2013     1     7     1042            900       102     1620           1530\n 8  2013     1     8      901            900         1     1504           1530\n 9  2013     1     9      641            900      1301     1242           1530\n10  2013     1    10      859            900        -1     1449           1530\n# ℹ 332 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\n\n\n\nÉvaluation contextuelle\n\n\n\ndplyr procède à une évaluation contextuelle des expressions qui lui sont passées. Ainsi, on peut indiquer directement le nom d’une variable et dplyr l’interprétera dans le contexte du tableau de données, c’est-à-dire regardera s’il existe une colonne portant ce nom dans le tableau.\nDans l’expression flights |&gt; filter(month == 1), month est interprété comme la colonne month du tableau flights, à savoir flights$month.\nIl est également possible d’indiquer des objets extérieurs au tableau :\n\nm &lt;- 2\nflights |&gt; \n  filter(month == m)\n\n# A tibble: 24,951 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     2     1      456            500        -4      652            648\n 2  2013     2     1      520            525        -5      816            820\n 3  2013     2     1      527            530        -3      837            829\n 4  2013     2     1      532            540        -8     1007           1017\n 5  2013     2     1      540            540         0      859            850\n 6  2013     2     1      552            600        -8      714            715\n 7  2013     2     1      552            600        -8      919            910\n 8  2013     2     1      552            600        -8      655            709\n 9  2013     2     1      553            600        -7      833            815\n10  2013     2     1      553            600        -7      821            825\n# ℹ 24,941 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCelà fonctionne parce qu’il n’y a pas de colonne m dans la table. Donc dplyr cherche une variable m dans l’environnement de travail.\n\n\n\n\nslice()\nSOURCE\nLe verbe dplyr::slice() sélectionne des lignes du tableau selon leur position.\nLa \\(345^{ème}\\) ligne du tableau airports :\n\nairports |&gt; \n  slice(345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nPlusieurs lignes :\n\nairports |&gt; \n  slice(3:5)\n\n# A tibble: 3 × 8\n  faa   name                    lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 06C   Schaumburg Regional    42.0 -88.1   801    -6 A     America/Chicago \n2 06N   Randall Airport        41.4 -74.4   523    -5 A     America/New_York\n3 09J   Jekyll Island Airport  31.1 -81.4    11    -5 A     America/New_York\n\n\n\n\narrange()\ndplyr::arrange() réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nTrier flighs selon le retard au départ5 en ordre croissant :\n5 colonne (variable) dep_delay\nflights |&gt; \n  arrange(dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nTrier selon plusieurs colonnes :\n\nflights |&gt; \n  arrange(month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nEt même :\n\nflights |&gt; \n  arrange(month, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nLà, month est en ordre ascendant et dep_delay en ordre descendant.\nCombiné dplyr::slice() et dplyr::arrange() pour, entre autres, trouver les 3 vols ayant eu le plus de retard :\n\nflights |&gt; \n  arrange(desc(dep_delay)) |&gt; \n  slice(1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;"
  },
  {
    "objectID": "005_dplyr.html",
    "href": "005_dplyr.html",
    "title": "dplyr",
    "section": "",
    "text": "dplyr facilite le traitement et la manipulation des tableaux de données (qu’il s’agisse de data frame ou de tibble). Il propose une syntaxe claire et cohérente, sous formes de verbes correspondant à des fonctions.\nLes verbes de dplyr prennent en entrée un tableau de données (data frame ou tibble) et renvoient systématiquement un tibble.\nCharger le package :\nlibrary(dplyr, warn.conflicts = FALSE)\nCharger le jeu de données nycflights13, données de tous les vols au départ des aéroports de New-York en 2013, répartis en 3 tables1 :\nCharger le package :\nlibrary(nycflights13)\nCharger les tables :\ndata(flights)\ndata(airports)\ndata(airlines)"
  },
  {
    "objectID": "005_dplyr.html#opérations-sur-les-lignes",
    "href": "005_dplyr.html#opérations-sur-les-lignes",
    "title": "dplyr",
    "section": "1 Opérations sur les lignes",
    "text": "1 Opérations sur les lignes\n\n1.1 filter()\nfilter() des lignes d’une table selon une condition passée en paramètre.\nSeules les lignes pour lesquelles le test renvoie TRUE sont renvoyées2.\n2 une ligne pour laquelle le test renvoie FALSE (faux) ou NA, d’est à dire non avable (valeur manquante) sera ignorée, donc pas renvoyée3 variable monthSélection des vols du mois de janvier3 :\n\nfilter(flights, month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nOu plus simplement avec un pipe :\n\nflights |&gt; \n  filter(month == 1)\n\n# A tibble: 27,004 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 26,994 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nSélectionner les vols avec un retard au départ4 entre 10 et 15 minutes :\n4 variable dep_delay\nflights |&gt; \n  filter(dep_delay &gt;= 10 & dep_delay &lt;= 15)\n\n# A tibble: 14,919 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      611            600        11      945            931\n 2  2013     1     1      623            610        13      920            915\n 3  2013     1     1      743            730        13     1107           1100\n 4  2013     1     1      743            730        13     1059           1056\n 5  2013     1     1      851            840        11     1215           1206\n 6  2013     1     1      912            900        12     1241           1220\n 7  2013     1     1      914            900        14     1058           1043\n 8  2013     1     1      920            905        15     1039           1025\n 9  2013     1     1     1011           1001        10     1133           1128\n10  2013     1     1     1112           1100        12     1440           1438\n# ℹ 14,909 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nTester avec une fonction. Les vols avec la plus grande distance :\n\nflights |&gt; \n  filter(distance == max(distance))\n\n# A tibble: 342 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      857            900        -3     1516           1530\n 2  2013     1     2      909            900         9     1525           1530\n 3  2013     1     3      914            900        14     1504           1530\n 4  2013     1     4      900            900         0     1516           1530\n 5  2013     1     5      858            900        -2     1519           1530\n 6  2013     1     6     1019            900        79     1558           1530\n 7  2013     1     7     1042            900       102     1620           1530\n 8  2013     1     8      901            900         1     1504           1530\n 9  2013     1     9      641            900      1301     1242           1530\n10  2013     1    10      859            900        -1     1449           1530\n# ℹ 332 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\n\n\n\nÉvaluation contextuelle\n\n\n\ndplyr procède à une évaluation contextuelle des expressions qui lui sont passées. Ainsi, on peut indiquer directement le nom d’une variable et dplyr l’interprétera dans le contexte du tableau de données, c’est-à-dire regardera s’il existe une colonne portant ce nom dans le tableau.\nDans l’expression flights |&gt; filter(month == 1), month est interprété comme la colonne month du tableau flights, à savoir flights$month.\nIl est également possible d’indiquer des objets extérieurs au tableau :\n\nm &lt;- 2\nflights |&gt; \n  filter(month == m)\n\n# A tibble: 24,951 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     2     1      456            500        -4      652            648\n 2  2013     2     1      520            525        -5      816            820\n 3  2013     2     1      527            530        -3      837            829\n 4  2013     2     1      532            540        -8     1007           1017\n 5  2013     2     1      540            540         0      859            850\n 6  2013     2     1      552            600        -8      714            715\n 7  2013     2     1      552            600        -8      919            910\n 8  2013     2     1      552            600        -8      655            709\n 9  2013     2     1      553            600        -7      833            815\n10  2013     2     1      553            600        -7      821            825\n# ℹ 24,941 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nCelà fonctionne parce qu’il n’y a pas de colonne m dans la table. Donc dplyr cherche une variable m dans l’environnement de travail.\n\n\n\n\n1.2 slice()\nSOURCE\nLe verbe dplyr::slice() sélectionne des lignes du tableau selon leur position.\nLa 345^{ème} ligne du tableau airports :\n\nairports |&gt; \n  slice(345)\n\n# A tibble: 1 × 8\n  faa   name                lat   lon   alt    tz dst   tzone            \n  &lt;chr&gt; &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;            \n1 CYF   Chefornak Airport  60.1 -164.    40    -9 A     America/Anchorage\n\n\nPlusieurs lignes :\n\nairports |&gt; \n  slice(3:5)\n\n# A tibble: 3 × 8\n  faa   name                    lat   lon   alt    tz dst   tzone           \n  &lt;chr&gt; &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           \n1 06C   Schaumburg Regional    42.0 -88.1   801    -6 A     America/Chicago \n2 06N   Randall Airport        41.4 -74.4   523    -5 A     America/New_York\n3 09J   Jekyll Island Airport  31.1 -81.4    11    -5 A     America/New_York\n\n\n\n\n1.3 arrange()\ndplyr::arrange() réordonne les lignes d’un tableau selon une ou plusieurs colonnes.\nTrier flighs selon le retard au départ5 en ordre croissant :\n5 colonne (variable) dep_delay\nflights |&gt; \n  arrange(dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013    12     7     2040           2123       -43       40           2352\n 2  2013     2     3     2022           2055       -33     2240           2338\n 3  2013    11    10     1408           1440       -32     1549           1559\n 4  2013     1    11     1900           1930       -30     2233           2243\n 5  2013     1    29     1703           1730       -27     1947           1957\n 6  2013     8     9      729            755       -26     1002            955\n 7  2013    10    23     1907           1932       -25     2143           2143\n 8  2013     3    30     2030           2055       -25     2213           2250\n 9  2013     3     2     1431           1455       -24     1601           1631\n10  2013     5     5      934            958       -24     1225           1309\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nTrier selon plusieurs colonnes :\n\nflights |&gt; \n  arrange(month, dep_delay)\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1    11     1900           1930       -30     2233           2243\n 2  2013     1    29     1703           1730       -27     1947           1957\n 3  2013     1    12     1354           1416       -22     1606           1650\n 4  2013     1    21     2137           2159       -22     2232           2316\n 5  2013     1    20      704            725       -21     1025           1035\n 6  2013     1    12     2050           2110       -20     2310           2355\n 7  2013     1    12     2134           2154       -20        4             50\n 8  2013     1    14     2050           2110       -20     2329           2355\n 9  2013     1     4     2140           2159       -19     2241           2316\n10  2013     1    11     1947           2005       -18     2209           2230\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nEt même :\n\nflights |&gt; \n  arrange(month, desc(dep_delay))\n\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     1    10     1121           1635      1126     1239           1810\n 3  2013     1     1      848           1835       853     1001           1950\n 4  2013     1    13     1809            810       599     2054           1042\n 5  2013     1    16     1622            800       502     1911           1054\n 6  2013     1    23     1551            753       478     1812           1006\n 7  2013     1    10     1525            900       385     1713           1039\n 8  2013     1     1     2343           1724       379      314           1938\n 9  2013     1     2     2131           1512       379     2340           1741\n10  2013     1     7     2021           1415       366     2332           1724\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nLà, month est en ordre ascendant et dep_delay en ordre descendant.\nCombiné dplyr::slice() et dplyr::arrange() pour, entre autres, trouver les 3 vols ayant eu le plus de retard :\n\nflights |&gt; \n  arrange(desc(dep_delay)) |&gt; \n  slice(1:3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013     1     9      641            900      1301     1242           1530\n2  2013     6    15     1432           1935      1137     1607           2120\n3  2013     1    10     1121           1635      1126     1239           1810\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n1.4 slice_sample()\ndplyr::slice_sample() permet de sélectionner aléatoirement un certain nombres de lignes ou un pourcentage de lignes :\n\nflights |&gt; \n  slice_sample(n = 3)\n\n# A tibble: 3 × 19\n   year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n1  2013    11    11     1433           1425         8     1645           1653\n2  2013    11    13     1300           1245        15     1438           1435\n3  2013    10     5     1706           1715        -9     1847           1905\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nou pour trouver 2.3\\,\\% des lignes :\n\nflights |&gt; \n  slice_sample(prop = 0.023)\n\n# A tibble: 7,745 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     8      601            605        -4      801            805\n 2  2013     5    28     1358           1359        -1     1555           1556\n 3  2013     6    13     1015            959        16     1259           1207\n 4  2013     1    25      837            835         2     1202           1150\n 5  2013    12    15     1507           1510        -3     1834           1835\n 6  2013     9    29     1616           1620        -4     1757           1828\n 7  2013     2    21     1050           1029        21     1240           1235\n 8  2013    12    14      706            710        -4      838            840\n 9  2013    12    17      629            630        -1     1003            938\n10  2013     9    13     1342           1345        -3     1534           1544\n# ℹ 7,735 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\n\n\n\n\n\n\nNote\n\n\n\nPour demander un pourcentage à R, il faut lui passer un nombre rationnel, entre 0.000 et 1.000. 5\\,\\% s’écrit \\frac{5}{100} = 0.05\n\n\n\n\n\n\n\n\nImportant\n\n\n\nPour avoir des résultats reproductibles et dans le temps et sur différentes machines, il FAUT utiliser set.seed().\nSans entrer trop dans les détails6, les programmes génèrent des nombres pseudo-aléatoires. Un ordinateur ne sait faire que des calculs. Pour choisir un nombre au hasard, il fait un calcul du genre f(x), où x et le nombre affiché par un compteur interne à l’ordinateur qui change de valeur chaque millième de seconde. N’importe quel programme peut accéder et changer la valeur de ce compteur.\nTout ça pour dire qu’on ne peut pas, jamais faire confiance à l’aléatoire d’un ordinateur. Et set.seed() ?\nExemple :\n\nsample(letters, 3)\n\n[1] \"o\" \"h\" \"i\"\n\nsample(letters, 3)\n\n[1] \"c\" \"l\" \"d\"\n\nsample(letters, 3)\n\n[1] \"e\" \"p\" \"d\"\n\n\nÀ comparer à :\n\nset.seed(123)\nsample(letters, 3)\n\n[1] \"o\" \"s\" \"n\"\n\nset.seed(123)\nsample(letters, 3)\n\n[1] \"o\" \"s\" \"n\"\n\nset.seed(123)\nsample(letters, 3)\n\n[1] \"o\" \"s\" \"n\"\n\n\nLe programme choisit toujours des lettres au hasard. Mais chaque séquence produit le même résultat.\nslice_sample() sert à choisir un extrait d’une table pour faire des essais. Si les extraits successifs ne sont pas les mêmes, les résultats des essais seront biaisés et, surtout, incohérents. En utilisant set.seed()7. En définissant une même semence avant chaque génération aléatoire, on aura toujours la même séquence aléatoire. Et sur touts les machines du monde.\n\n\n7 à noter pour les anglophobes : seed veut dire semence6 quoique j’y suis peut-être déjà !\n\n1.5 distinct()\ndplyr::distinct() renvoie un tableau sans lignes en double.\n\nflights |&gt; \n  select(day, month) |&gt;\n  distinct()\n\n# A tibble: 365 × 2\n     day month\n   &lt;int&gt; &lt;int&gt;\n 1     1     1\n 2     2     1\n 3     3     1\n 4     4     1\n 5     5     1\n 6     6     1\n 7     7     1\n 8     8     1\n 9     9     1\n10    10     1\n# ℹ 355 more rows\n\n\nOn peut lui spécifier une liste de variables : dans ce cas, pour toutes les observations ayant des valeurs identiques pour les variables en question, distinct() ne conservera que la première d’entre elles.\n\nflights |&gt; \n  distinct(month, day)\n\n# A tibble: 365 × 2\n   month   day\n   &lt;int&gt; &lt;int&gt;\n 1     1     1\n 2     1     2\n 3     1     3\n 4     1     4\n 5     1     5\n 6     1     6\n 7     1     7\n 8     1     8\n 9     1     9\n10     1    10\n# ℹ 355 more rows\n\n\nL’option .keep_all renvoie toutes les colonnes du tableau :\n\nflights |&gt; \n  distinct(month, day, .keep_all = TRUE)\n\n# A tibble: 365 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     2       42           2359        43      518            442\n 3  2013     1     3       32           2359        33      504            442\n 4  2013     1     4       25           2359        26      505            442\n 5  2013     1     5       14           2359        15      503            445\n 6  2013     1     6       16           2359        17      451            442\n 7  2013     1     7       49           2359        50      531            444\n 8  2013     1     8      454            500        -6      625            648\n 9  2013     1     9        2           2359         3      432            444\n10  2013     1    10        3           2359         4      426            437\n# ℹ 355 more rows\n# ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;"
  },
  {
    "objectID": "005_dplyr.html#opérations-sur-les-colonnes",
    "href": "005_dplyr.html#opérations-sur-les-colonnes",
    "title": "dplyr",
    "section": "2 Opérations sur les colonnes",
    "text": "2 Opérations sur les colonnes\nSource\n\n2.1 select()\ndplyr::select() permet de sélectionner des colonnes d’un tableau de données. Extraire les colonnes lat et lon du tableau airports :\n\nairports |&gt; \n  select(lat, lon)\n\n# A tibble: 1,458 × 2\n     lat    lon\n   &lt;dbl&gt;  &lt;dbl&gt;\n 1  41.1  -80.6\n 2  32.5  -85.7\n 3  42.0  -88.1\n 4  41.4  -74.4\n 5  31.1  -81.4\n 6  36.4  -82.2\n 7  41.5  -84.5\n 8  42.9  -76.8\n 9  39.8  -76.6\n10  48.1 -123. \n# ℹ 1,448 more rows\n\n\nPrécéder le nom de la colonne d’un - élimine la colonne de la sélection :\n\nairports |&gt; \n  select(-lat, -lon)\n\n# A tibble: 1,458 × 6\n   faa   name                             alt    tz dst   tzone              \n   &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;              \n 1 04G   Lansdowne Airport               1044    -5 A     America/New_York   \n 2 06A   Moton Field Municipal Airport    264    -6 A     America/Chicago    \n 3 06C   Schaumburg Regional              801    -6 A     America/Chicago    \n 4 06N   Randall Airport                  523    -5 A     America/New_York   \n 5 09J   Jekyll Island Airport             11    -5 A     America/New_York   \n 6 0A9   Elizabethton Municipal Airport  1593    -5 A     America/New_York   \n 7 0G6   Williams County Airport          730    -5 A     America/New_York   \n 8 0G7   Finger Lakes Regional Airport    492    -5 A     America/New_York   \n 9 0P2   Shoestring Aviation Airfield    1000    -5 U     America/New_York   \n10 0S9   Jefferson County Intl            108    -8 A     America/Los_Angeles\n# ℹ 1,448 more rows\n\n\ndplyr::select() comprend une série de fonctions facilitant la sélection de multiples colonnes. Par exemple, dplyr::starts_with(), dplyr::contains() ou dplyr::matches() permettent d’exprimer des conditions sur les noms de variables :\n\nflights |&gt; \n  select(starts_with(\"dep_\"))\n\n# A tibble: 336,776 × 2\n   dep_time dep_delay\n      &lt;int&gt;     &lt;dbl&gt;\n 1      517         2\n 2      533         4\n 3      542         2\n 4      544        -1\n 5      554        -6\n 6      554        -4\n 7      555        -5\n 8      557        -3\n 9      557        -3\n10      558        -2\n# ℹ 336,766 more rows\n\n\ncolonneA:colonneZ permet de sélectionner toutes les colonnes entre colonneA et colonneZ, ces deux colonnes incluses :\n\nflights |&gt; \n  select(year:day)\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\ndplyr::all_of() et dplyr::any_of() permettent de fournir une liste de variables à extraire sous forme de vecteur textuel. Alors que dplyr::all_of() renverra une erreur si une variable n’est pas trouvée dans le tableau de départ, dplyr::any_of() sera moins stricte.\n\nflights |&gt; \n  select(all_of(c(\"year\", \"month\", \"day\")))\n\n# A tibble: 336,776 × 3\n    year month   day\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n\n\ndplyr::where() permets de sélectionner des variables à partir d’une fonction qui renvoie une valeur logique. Par exemple, pour sélectionner seulement les variables textuelles :\n\nflights |&gt; \n  select(where(is.character))\n\n# A tibble: 336,776 × 4\n   carrier tailnum origin dest \n   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;\n 1 UA      N14228  EWR    IAH  \n 2 UA      N24211  LGA    IAH  \n 3 AA      N619AA  JFK    MIA  \n 4 B6      N804JB  JFK    BQN  \n 5 DL      N668DN  LGA    ATL  \n 6 UA      N39463  EWR    ORD  \n 7 B6      N516JB  EWR    FLL  \n 8 EV      N829AS  LGA    IAD  \n 9 B6      N593JB  JFK    MCO  \n10 AA      N3ALAA  LGA    ORD  \n# ℹ 336,766 more rows\n\n\ndplyr::select() peut être utilisée pour réordonner les colonnes d’une table en utilisant la fonction dplyr::everything(), qui sélectionne l’ensemble des colonnes non encore sélectionnées. Ainsi, si l’on souhaite faire passer la colonne name en première position de la table airports, on peut faire :\n\nairports |&gt; \n  select(name, everything())\n\n# A tibble: 1,458 × 8\n   name                           faa     lat    lon   alt    tz dst   tzone    \n   &lt;chr&gt;                          &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1 Lansdowne Airport              04G    41.1  -80.6  1044    -5 A     America/…\n 2 Moton Field Municipal Airport  06A    32.5  -85.7   264    -6 A     America/…\n 3 Schaumburg Regional            06C    42.0  -88.1   801    -6 A     America/…\n 4 Randall Airport                06N    41.4  -74.4   523    -5 A     America/…\n 5 Jekyll Island Airport          09J    31.1  -81.4    11    -5 A     America/…\n 6 Elizabethton Municipal Airport 0A9    36.4  -82.2  1593    -5 A     America/…\n 7 Williams County Airport        0G6    41.5  -84.5   730    -5 A     America/…\n 8 Finger Lakes Regional Airport  0G7    42.9  -76.8   492    -5 A     America/…\n 9 Shoestring Aviation Airfield   0P2    39.8  -76.6  1000    -5 U     America/…\n10 Jefferson County Intl          0S9    48.1 -123.    108    -8 A     America/…\n# ℹ 1,448 more rows\n\n\n\n\n2.2 relocate()\nPour réordonner des colonnes, on pourra aussi avoir recours à dplyr::relocate() en indiquant les premières variables. Il n’est pas nécessaire d’ajouter everything() car avec dplyr::relocate() toutes les variables sont conservées.\n\nairports |&gt; \n  relocate(lon, lat, name)\n\n# A tibble: 1,458 × 8\n      lon   lat name                           faa     alt    tz dst   tzone    \n    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                          &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    \n 1  -80.6  41.1 Lansdowne Airport              04G    1044    -5 A     America/…\n 2  -85.7  32.5 Moton Field Municipal Airport  06A     264    -6 A     America/…\n 3  -88.1  42.0 Schaumburg Regional            06C     801    -6 A     America/…\n 4  -74.4  41.4 Randall Airport                06N     523    -5 A     America/…\n 5  -81.4  31.1 Jekyll Island Airport          09J      11    -5 A     America/…\n 6  -82.2  36.4 Elizabethton Municipal Airport 0A9    1593    -5 A     America/…\n 7  -84.5  41.5 Williams County Airport        0G6     730    -5 A     America/…\n 8  -76.8  42.9 Finger Lakes Regional Airport  0G7     492    -5 A     America/…\n 9  -76.6  39.8 Shoestring Aviation Airfield   0P2    1000    -5 U     America/…\n10 -123.   48.1 Jefferson County Intl          0S9     108    -8 A     America/…\n# ℹ 1,448 more rows\n\n\n\n\n2.3 rename()\nUne variante de dplyr::select() est dplyr::rename(), qui permet de renommer facilement des colonnes. On l’utilise en lui passant des paramètres de la forme nouveau_nom = ancien_nom. Ainsi, si on veut renommer les colonnes lon et lat de airports en longitude et latitude :\n\nairports |&gt; \n  rename(longitude = lon, latitude = lat)\n\n# A tibble: 1,458 × 8\n   faa   name                         latitude longitude   alt    tz dst   tzone\n   &lt;chr&gt; &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n 1 04G   Lansdowne Airport                41.1     -80.6  1044    -5 A     Amer…\n 2 06A   Moton Field Municipal Airpo…     32.5     -85.7   264    -6 A     Amer…\n 3 06C   Schaumburg Regional              42.0     -88.1   801    -6 A     Amer…\n 4 06N   Randall Airport                  41.4     -74.4   523    -5 A     Amer…\n 5 09J   Jekyll Island Airport            31.1     -81.4    11    -5 A     Amer…\n 6 0A9   Elizabethton Municipal Airp…     36.4     -82.2  1593    -5 A     Amer…\n 7 0G6   Williams County Airport          41.5     -84.5   730    -5 A     Amer…\n 8 0G7   Finger Lakes Regional Airpo…     42.9     -76.8   492    -5 A     Amer…\n 9 0P2   Shoestring Aviation Airfield     39.8     -76.6  1000    -5 U     Amer…\n10 0S9   Jefferson County Intl            48.1    -123.    108    -8 A     Amer…\n# ℹ 1,448 more rows\n\n\n\n\n2.4 pull()\nLa fonction dplyr::pull() permet d’accéder au contenu d’une variable. C’est un équivalent aux opérateurs $ ou [[]]. On peut lui passer un nom de variable ou bien sa position.\n\nairports |&gt; \n  pull(alt) |&gt; \n  mean()\n\n[1] 1001.416\n\n\n\n\n2.5 mutate()\nSource\ndplyr::mutate() permet de créer de nouvelles colonnes dans le tableau de données, en général à partir de variables existantes.\nPar exemple, la table airports contient l’altitude de l’aéroport en pieds. Si l’on veut créer une nouvelle variable alt_m avec l’altitude en mètres, on peut faire :\n\nairports &lt;- \n  airports |&gt; \n  mutate(alt_m = alt / 3.2808)\nairports\n\n# A tibble: 1,458 × 9\n   faa   name                          lat    lon   alt    tz dst   tzone  alt_m\n   &lt;chr&gt; &lt;chr&gt;                       &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n 1 04G   Lansdowne Airport            41.1  -80.6  1044    -5 A     Amer… 318.  \n 2 06A   Moton Field Municipal Airp…  32.5  -85.7   264    -6 A     Amer…  80.5 \n 3 06C   Schaumburg Regional          42.0  -88.1   801    -6 A     Amer… 244.  \n 4 06N   Randall Airport              41.4  -74.4   523    -5 A     Amer… 159.  \n 5 09J   Jekyll Island Airport        31.1  -81.4    11    -5 A     Amer…   3.35\n 6 0A9   Elizabethton Municipal Air…  36.4  -82.2  1593    -5 A     Amer… 486.  \n 7 0G6   Williams County Airport      41.5  -84.5   730    -5 A     Amer… 223.  \n 8 0G7   Finger Lakes Regional Airp…  42.9  -76.8   492    -5 A     Amer… 150.  \n 9 0P2   Shoestring Aviation Airfie…  39.8  -76.6  1000    -5 U     Amer… 305.  \n10 0S9   Jefferson County Intl        48.1 -123.    108    -8 A     Amer…  32.9 \n# ℹ 1,448 more rows\n\n\nOn peut créer plusieurs nouvelles colonnes en une seule fois, et les expressions successives peuvent prendre en compte les résultats des calculs précédents. L’exemple suivant convertit d’abord la distance en kilomètres dans une variable distance_km, puis utilise cette nouvelle colonne pour calculer la vitesse en km/h.\n\nflights &lt;- \n  flights |&gt; \n  mutate(\n    distance_km = distance / 0.62137,\n    vitesse_kmh = distance_km / air_time * 60\n  )\nflights\n\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;,\n#   vitesse_kmh &lt;dbl&gt;"
  },
  {
    "objectID": "005_dplyr.html#opérations-groupées",
    "href": "005_dplyr.html#opérations-groupées",
    "title": "dplyr",
    "section": "3 Opérations groupées",
    "text": "3 Opérations groupées\n\n3.1 group_by()\nUn élément très important de dplyr est la fonction dplyr::group_by(). Elle permet de définir des groupes de lignes à partir des valeurs d’une ou plusieurs colonnes. Par exemple, on peut grouper les vols selon leur mois :\n\nflights |&gt; \n  group_by(month)\n\n# A tibble: 336,776 × 21\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;,\n#   vitesse_kmh &lt;dbl&gt;\n\n\nPar défaut ceci ne fait rien de visible, à part l’apparition d’une mention Groups dans l’affichage du résultat. Mais à partir du moment où des groupes ont été définis, les verbes comme dplyr::slice() ou dplyr::mutate() vont en tenir compte lors de leurs opérations.\nPar exemple, si on applique dplyr::slice() à un tableau préalablement groupé, il va sélectionner les lignes aux positions indiquées pour chaque groupe. Ainsi la commande suivante affiche le premier vol de chaque mois, selon leur ordre d’apparition dans le tableau :\n\nflights |&gt; \n  group_by(month) |&gt; \n  slice(1)\n\n# A tibble: 12 × 21\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     1      517            515         2      830            819\n 2  2013     2     1      456            500        -4      652            648\n 3  2013     3     1        4           2159       125      318             56\n 4  2013     4     1      454            500        -6      636            640\n 5  2013     5     1        9           1655       434      308           2020\n 6  2013     6     1        2           2359         3      341            350\n 7  2013     7     1        1           2029       212      236           2359\n 8  2013     8     1       12           2130       162      257             14\n 9  2013     9     1        9           2359        10      343            340\n10  2013    10     1      447            500       -13      614            648\n11  2013    11     1        5           2359         6      352            345\n12  2013    12     1       13           2359        14      446            445\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;,\n#   vitesse_kmh &lt;dbl&gt;\n\n\nIdem pour dplyr::mutate() : les opérations appliquées lors du calcul des valeurs des nouvelles colonnes sont appliquée groupe de lignes par groupe de lignes. Dans l’exemple suivant, on ajoute une nouvelle colonne qui contient le retard moyen du mois correspondant :\n\nflights |&gt; \n  group_by(month) |&gt; \n  mutate(mean_delay_month = mean(dep_delay, na.rm = TRUE)) |&gt; \n  relocate(mean_delay_month) |&gt; \n  slice(1)\n\n# A tibble: 12 × 22\n# Groups:   month [12]\n   mean_delay_month  year month   day dep_time sched_dep_time dep_delay arr_time\n              &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1            10.0   2013     1     1      517            515         2      830\n 2            10.8   2013     2     1      456            500        -4      652\n 3            13.2   2013     3     1        4           2159       125      318\n 4            13.9   2013     4     1      454            500        -6      636\n 5            13.0   2013     5     1        9           1655       434      308\n 6            20.8   2013     6     1        2           2359         3      341\n 7            21.7   2013     7     1        1           2029       212      236\n 8            12.6   2013     8     1       12           2130       162      257\n 9             6.72  2013     9     1        9           2359        10      343\n10             6.24  2013    10     1      447            500       -13      614\n11             5.44  2013    11     1        5           2359         6      352\n12            16.6   2013    12     1       13           2359        14      446\n# ℹ 14 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,\n#   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,\n#   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;,\n#   distance_km &lt;dbl&gt;, vitesse_kmh &lt;dbl&gt;\n\n\nCeci peut permettre, par exemple, de déterminer si un retard donné est supérieur ou inférieur au retard moyen du mois en cours.\ndplyr::group_by() peut aussi être utile avec dplyr::filter(), par exemple pour sélectionner les vols avec le retard au départ le plus important pour chaque mois :\n\nflights |&gt; \n  group_by(month) |&gt; \n  filter(dep_delay == max(dep_delay, na.rm = TRUE))\n\n# A tibble: 12 × 21\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013    10    14     2042            900       702     2255           1127\n 3  2013    11     3      603           1645       798      829           1913\n 4  2013    12     5      756           1700       896     1058           2020\n 5  2013     2    10     2243            830       853      100           1106\n 6  2013     3    17     2321            810       911      135           1020\n 7  2013     4    10     1100           1900       960     1342           2211\n 8  2013     5     3     1133           2055       878     1250           2215\n 9  2013     6    15     1432           1935      1137     1607           2120\n10  2013     7    22      845           1600      1005     1044           1815\n11  2013     8     8     2334           1454       520      120           1710\n12  2013     9    20     1139           1845      1014     1457           2210\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;,\n#   vitesse_kmh &lt;dbl&gt;\n\n\n\n\n\n\n\n\nAvertissement\n\n\n\nLa clause dplyr::group_by() marche pour les verbes déjà vus précédemment, sauf pour dplyr::arrange(), qui par défaut trie la table sans tenir compte des groupes. Pour obtenir un tri par groupe, il faut lui ajouter l’argument .by_group = TRUE.\nOn peut voir la différence en comparant les deux résultats suivants :\n\nflights |&gt; \n  group_by(month) |&gt; \n  arrange(desc(dep_delay)) |&gt; \n  relocate(dep_delay)\n\n# A tibble: 336,776 × 21\n# Groups:   month [12]\n   dep_delay  year month   day dep_time sched_dep_time arr_time sched_arr_time\n       &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n 1      1301  2013     1     9      641            900     1242           1530\n 2      1137  2013     6    15     1432           1935     1607           2120\n 3      1126  2013     1    10     1121           1635     1239           1810\n 4      1014  2013     9    20     1139           1845     1457           2210\n 5      1005  2013     7    22      845           1600     1044           1815\n 6       960  2013     4    10     1100           1900     1342           2211\n 7       911  2013     3    17     2321            810      135           1020\n 8       899  2013     6    27      959           1900     1236           2226\n 9       898  2013     7    22     2257            759      121           1026\n10       896  2013    12     5      756           1700     1058           2020\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;,\n#   vitesse_kmh &lt;dbl&gt;\n\nflights |&gt; \n  group_by(month) |&gt; \n  arrange(desc(dep_delay), .by_group = TRUE) |&gt; \n  relocate(dep_delay)\n\n# A tibble: 336,776 × 21\n# Groups:   month [12]\n   dep_delay  year month   day dep_time sched_dep_time arr_time sched_arr_time\n       &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n 1      1301  2013     1     9      641            900     1242           1530\n 2      1126  2013     1    10     1121           1635     1239           1810\n 3       853  2013     1     1      848           1835     1001           1950\n 4       599  2013     1    13     1809            810     2054           1042\n 5       502  2013     1    16     1622            800     1911           1054\n 6       478  2013     1    23     1551            753     1812           1006\n 7       385  2013     1    10     1525            900     1713           1039\n 8       379  2013     1     1     2343           1724      314           1938\n 9       379  2013     1     2     2131           1512     2340           1741\n10       366  2013     1     7     2021           1415     2332           1724\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,\n#   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, distance_km &lt;dbl&gt;,\n#   vitesse_kmh &lt;dbl&gt;\n\n\n\n\n\n\n3.2 summarise()\nSource\ndplyr::summarise() permet d’agréger les lignes du tableau en effectuant une opération résumée sur une ou plusieurs colonnes. Il s’agit de toutes les fonctions qui prennent en entrée un ensemble de valeurs et renvoie une valeur unique, comme la moyenne (mean()). Par exemple, si l’on souhaite connaître les retards moyens au départ et à l’arrivée pour l’ensemble des vols du tableau flights :\n\nflights |&gt; \n  summarise(\n    retard_dep = mean(dep_delay, na.rm = TRUE),\n    retard_arr = mean(arr_delay, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  retard_dep retard_arr\n       &lt;dbl&gt;      &lt;dbl&gt;\n1       12.6       6.90\n\n\nCette fonction est en général utilisée avec dplyr::group_by(), puisqu’elle permet du coup d’agréger et de résumer les lignes du tableau groupe par groupe. Si l’on souhaite calculer le délai maximum, le délai minimum et le délai moyen au départ pour chaque mois, on pourra faire :\n\nflights |&gt; \n  group_by(month) |&gt; \n  summarise(\n    max_delay = max(dep_delay, na.rm = TRUE),\n    min_delay = min(dep_delay, na.rm = TRUE),\n    mean_delay = mean(dep_delay, na.rm = TRUE)\n  )\n\n# A tibble: 12 × 4\n   month max_delay min_delay mean_delay\n   &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1     1      1301       -30      10.0 \n 2     2       853       -33      10.8 \n 3     3       911       -25      13.2 \n 4     4       960       -21      13.9 \n 5     5       878       -24      13.0 \n 6     6      1137       -21      20.8 \n 7     7      1005       -22      21.7 \n 8     8       520       -26      12.6 \n 9     9      1014       -24       6.72\n10    10       702       -25       6.24\n11    11       798       -32       5.44\n12    12       896       -43      16.6 \n\n\ndplyr::summarise() dispose d’une fonction spéciale dplyr::n(), qui retourne le nombre de lignes du groupe. Ainsi si l’on veut le nombre de vols par destination, on peut utiliser :\n\nflights |&gt; \n  group_by(dest) |&gt; \n  summarise(n = n())\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\nEssai\n\nflights |&gt; \n  group_by(month, dest) |&gt; \n  summarise(n = n())\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows\n\n\ndplyr::n() peut aussi être utilisée avec dplyr::filter() et dplyr::mutate().\n\n\n3.3 count()\nÀ noter que quand l’on veut compter le nombre de lignes par groupe, on peut utiliser directement la fonction dplyr::count(). Ainsi le code suivant est identique au précédent :\n\nflights |&gt; \n  count(dest)\n\n# A tibble: 105 × 2\n   dest      n\n   &lt;chr&gt; &lt;int&gt;\n 1 ABQ     254\n 2 ACK     265\n 3 ALB     439\n 4 ANC       8\n 5 ATL   17215\n 6 AUS    2439\n 7 AVL     275\n 8 BDL     443\n 9 BGR     375\n10 BHM     297\n# ℹ 95 more rows\n\n\n\n\n3.4 Grouper selon plusieurs variables\nSource\nOn peut grouper selon plusieurs variables à la fois, il suffit de les indiquer dans la clause du dplyr::group_by() :\n\nflights |&gt; \n  group_by(month, dest) |&gt; \n  summarise(nb = n()) |&gt; \n  arrange(desc(nb))\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 3\n# Groups:   month [12]\n   month dest     nb\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     8 ORD    1604\n 2    10 ORD    1604\n 3     5 ORD    1582\n 4     9 ORD    1582\n 5     7 ORD    1573\n 6     6 ORD    1547\n 7     7 ATL    1511\n 8     8 ATL    1507\n 9     8 LAX    1505\n10     7 LAX    1500\n# ℹ 1,103 more rows\n\n\nOn peut également compter selon plusieurs variables :\n\nflights |&gt; \n  count(origin, dest) |&gt; \n  arrange(desc(n))\n\n# A tibble: 224 × 3\n   origin dest      n\n   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n\n\nOn peut utiliser plusieurs opérations de groupage dans le même pipeline. Ainsi, si l’on souhaite déterminer le couple origine/destination ayant le plus grand nombre de vols selon le mois de l’année, on devra procéder en deux étapes :\n\nd’abord grouper selon mois, origine et destination pour calculer le nombre de vols\npuis grouper uniquement selon le mois pour sélectionner la ligne avec la valeur maximale.\n\n\nflights |&gt; \n  group_by(month, origin, dest) |&gt; \n  summarise(nb = n()) |&gt; \n  group_by(month) |&gt; \n  filter(nb == max(nb))\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 12 × 4\n# Groups:   month [12]\n   month origin dest     nb\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1     1 JFK    LAX     937\n 2     2 JFK    LAX     834\n 3     3 JFK    LAX     960\n 4     4 JFK    LAX     935\n 5     5 JFK    LAX     960\n 6     6 JFK    LAX     928\n 7     7 JFK    LAX     985\n 8     8 JFK    LAX     979\n 9     9 JFK    LAX     925\n10    10 JFK    LAX     965\n11    11 JFK    LAX     907\n12    12 JFK    LAX     947\n\n\n\n\n\n\n\n\nMise en garde\n\n\n\nLorsqu’on effectue un dplyr::group_by() suivi d’un dplyr::summarise(), le tableau résultat est automatiquement dégroupé de la dernière variable de regroupement. Ainsi le tableau généré par le code suivant est groupé par month et origin8 :\n\nflights |&gt; \n  group_by(month, origin, dest) |&gt; \n  summarise(nb = n())\n\n`summarise()` has grouped output by 'month', 'origin'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 2,313 × 4\n# Groups:   month, origin [36]\n   month origin dest     nb\n   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;\n 1     1 EWR    ALB      64\n 2     1 EWR    ATL     362\n 3     1 EWR    AUS      51\n 4     1 EWR    AVL       2\n 5     1 EWR    BDL      37\n 6     1 EWR    BNA     111\n 7     1 EWR    BOS     430\n 8     1 EWR    BQN      31\n 9     1 EWR    BTV     100\n10     1 EWR    BUF     119\n# ℹ 2,303 more rows\n\n\n\n\n8 c’est expliqué dans le message affiché dans la console, cela peut être contrôlé avec l’argument .groups de dplyr::summarise(), dont les options sont décrites dans l’aide de la fonction.Cela peut permettre d’enchaîner les opérations groupées. Dans l’exemple suivant, on calcule le pourcentage des trajets pour chaque destination par rapport à tous les trajets du mois :\n\nflights |&gt; \n  group_by(month, dest) |&gt; \n  summarise(nb = n()) |&gt; \n  mutate(pourcentage = nb / sum(nb) * 100)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 4\n# Groups:   month [12]\n   month dest     nb pourcentage\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;       &lt;dbl&gt;\n 1     1 ALB      64     0.237  \n 2     1 ATL    1396     5.17   \n 3     1 AUS     169     0.626  \n 4     1 AVL       2     0.00741\n 5     1 BDL      37     0.137  \n 6     1 BHM      25     0.0926 \n 7     1 BNA     399     1.48   \n 8     1 BOS    1245     4.61   \n 9     1 BQN      93     0.344  \n10     1 BTV     223     0.826  \n# ℹ 1,103 more rows\n\n\nOn peut à tout moment dégrouper un tableau à l’aide de dplyr::ungroup(). Ce serait par exemple nécessaire, dans l’exemple précédent, si on voulait calculer le pourcentage sur le nombre total de vols plutôt que sur le nombre de vols par mois :\n\nflights |&gt; \n  group_by(month, dest) |&gt; \n  summarise(nb = n()) |&gt; \n  ungroup() |&gt; \n  mutate(pourcentage = nb / sum(nb) * 100)\n\n`summarise()` has grouped output by 'month'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,113 × 4\n   month dest     nb pourcentage\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;       &lt;dbl&gt;\n 1     1 ALB      64    0.0190  \n 2     1 ATL    1396    0.415   \n 3     1 AUS     169    0.0502  \n 4     1 AVL       2    0.000594\n 5     1 BDL      37    0.0110  \n 6     1 BHM      25    0.00742 \n 7     1 BNA     399    0.118   \n 8     1 BOS    1245    0.370   \n 9     1 BQN      93    0.0276  \n10     1 BTV     223    0.0662  \n# ℹ 1,103 more rows\n\n\n\n\n\n\n\n\nImportant\n\n\n\ndplyr::count(), par contre, renvoi un tableau non groupé :\n\nflights |&gt; \n  count(month, dest)\n\n# A tibble: 1,113 × 3\n   month dest      n\n   &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n 1     1 ALB      64\n 2     1 ATL    1396\n 3     1 AUS     169\n 4     1 AVL       2\n 5     1 BDL      37\n 6     1 BHM      25\n 7     1 BNA     399\n 8     1 BOS    1245\n 9     1 BQN      93\n10     1 BTV     223\n# ℹ 1,103 more rows"
  },
  {
    "objectID": "900_summarise.html",
    "href": "900_summarise.html",
    "title": "summarise",
    "section": "",
    "text": "Source:R/summarise.R\nsummarise() crée un nouveau bloc de données. Il renvoie une ligne pour chaque combinaison de variables de regroupement ; s’il n’y a pas de variables de regroupement, la sortie aura une seule ligne résumant toutes les observations dans l’entrée. Il contiendra une colonne pour chaque variable de regroupement et une colonne pour chacune des statistiques récapitulatives que vous avez spécifiées.\nsummarise()et summarize() sont des synonymes.\n\n\nsummarise(.data, ..., .by = NULL, .groups = NULL)\nsummarize(.data, ..., .by = NULL, .groups = NULL)\n\n\n\n\n.data\n\nUn jeu de données, une extension de jeu de données (par exemple un tibble). Voir Méthodes ci-dessous pour plus de détails.\n\n...\n\n&lt; data-masking&gt; Paires nom-valeur de fonctions récapitulatives. Le nom sera le nom de la variable dans le résultat.\n\n\nLa valeur peut être :\n\n\n\nUn vecteur de longueur 1, par exemple min(x), n(), ou sum(is.na(y))\nUn jeu de données, pour ajouter plusieurs colonnes à partir d’une seule expression.\n\n\n.by [Expérimental]\n\n&lt; tidy-select&gt; En option, une sélection de colonnes à regrouper uniquement pour cette opération, fonctionnant comme une alternative à group_by(). Pour plus de détails et des exemples, tapez ?dplyr_by .\n\n.groups [Expérimental]\n\nStructure de regroupement du résultat.\n\n\n\n“drop_last” : suppression du dernier niveau de regroupement. C’était la seule option prise en charge avant la version 1.0.0.\n“drop” : tous les niveaux de regroupement sont supprimés.\n“keep” : Même structure de regroupement que .data.\n“rowwise” : chaque ligne est son propre groupe.\n\n\n\nLorsque .groups n’est pas précisé, il est choisi en fonction du nombre de lignes des résultats :\n\n\n\nsi tous les résultats comportent 1 ligne, on obtient “drop_last”.\nsi le nombre de lignes varie, vous obtenez « keep » (à noté que le renvoi d’un nombre variable de lignes est obsolète au profit de reframe(), ce qui supprime également sans condition tous les niveaux de regroupement).\n\n\n\nDe plus, un message vous informe de ce choix, sauf si le résultat est ungroup(), si l’option “dplyr.summarise.inform” est définie sur FALSE, ou lorsque summarise() est appelée depuis une fonction d’un package.\n\n\n\nUn objet généralement du même type que .data.\n\nLes lignes proviennent du group_keys().\nLes colonnes sont une combinaison des clés de regroupement et des expressions récapitulatives fournient.\nLa structure de regroupement est contrôlée par l’argument .groups=, la sortie peut être un autre grouped_df , un tibble ou un jeu de données placé en rowwise()\nLes attributs du bloc de données ne sont pas conservés, car summarise() crée fondamentalement un nouveau jeu de données.\n\n\n\n\nCentre: mean(),median()\nPropagé: sd(), IQR(),mad()\nGamme: min(), max(),\nPosition: first(), last(), nth(),\nCompter: n(),n_distinct()\nLogique : any(),all()\nVariantes du back-end Le back-end du bloc de données prend en charge la création d’une variable et son utilisation dans le même résumé. Cela signifie que les variables récapitulatives créées précédemment peuvent être transformées ou combinées davantage dans le résumé, comme dans mutate(). Cependant, cela signifie également que les variables récapitulatives portant les mêmes noms que les variables précédentes les écrasent, rendant ces variables indisponibles pour les variables récapitulatives ultérieures.\nCe comportement peut ne pas être pris en charge dans d’autres backends. Pour éviter des résultats inattendus, envisagez d’utiliser de nouveaux noms pour vos variables récapitulatives, en particulier lors de la création de plusieurs résumés.\nMéthodes Cette fonction est générique , ce qui signifie que les packages peuvent fournir des implémentations (méthodes) pour d’autres classes. Consultez la documentation des méthodes individuelles pour connaître les arguments supplémentaires et les différences de comportement.\nLes méthodes suivantes sont actuellement disponibles dans les packages chargés : dbplyr ( tbl_lazy), dplyr ( data.frame, grouped_df, rowwise_df) .\nVoir également Autres verbes à table unique : arrange(), filter(), mutate(), reframe(), rename(), select(), slice()\nExemples # A summary applied to ungrouped tbl returns a single row mtcars %&gt;% summarise(mean = mean(disp), n = n()) #&gt; mean n #&gt; 1 230.7219 32"
  },
  {
    "objectID": "900_summarise.html#résumez-chaque-groupe-sur-une-seule-ligne",
    "href": "900_summarise.html#résumez-chaque-groupe-sur-une-seule-ligne",
    "title": "summarise",
    "section": "",
    "text": "Source:R/summarise.R\nsummarise() crée un nouveau bloc de données. Il renvoie une ligne pour chaque combinaison de variables de regroupement ; s’il n’y a pas de variables de regroupement, la sortie aura une seule ligne résumant toutes les observations dans l’entrée. Il contiendra une colonne pour chaque variable de regroupement et une colonne pour chacune des statistiques récapitulatives que vous avez spécifiées.\nsummarise()et summarize() sont des synonymes.\n\n\nsummarise(.data, ..., .by = NULL, .groups = NULL)\nsummarize(.data, ..., .by = NULL, .groups = NULL)\n\n\n\n\n.data\n\nUn jeu de données, une extension de jeu de données (par exemple un tibble). Voir Méthodes ci-dessous pour plus de détails.\n\n...\n\n&lt; data-masking&gt; Paires nom-valeur de fonctions récapitulatives. Le nom sera le nom de la variable dans le résultat.\n\n\nLa valeur peut être :\n\n\n\nUn vecteur de longueur 1, par exemple min(x), n(), ou sum(is.na(y))\nUn jeu de données, pour ajouter plusieurs colonnes à partir d’une seule expression.\n\n\n.by [Expérimental]\n\n&lt; tidy-select&gt; En option, une sélection de colonnes à regrouper uniquement pour cette opération, fonctionnant comme une alternative à group_by(). Pour plus de détails et des exemples, tapez ?dplyr_by .\n\n.groups [Expérimental]\n\nStructure de regroupement du résultat.\n\n\n\n“drop_last” : suppression du dernier niveau de regroupement. C’était la seule option prise en charge avant la version 1.0.0.\n“drop” : tous les niveaux de regroupement sont supprimés.\n“keep” : Même structure de regroupement que .data.\n“rowwise” : chaque ligne est son propre groupe.\n\n\n\nLorsque .groups n’est pas précisé, il est choisi en fonction du nombre de lignes des résultats :\n\n\n\nsi tous les résultats comportent 1 ligne, on obtient “drop_last”.\nsi le nombre de lignes varie, vous obtenez « keep » (à noté que le renvoi d’un nombre variable de lignes est obsolète au profit de reframe(), ce qui supprime également sans condition tous les niveaux de regroupement).\n\n\n\nDe plus, un message vous informe de ce choix, sauf si le résultat est ungroup(), si l’option “dplyr.summarise.inform” est définie sur FALSE, ou lorsque summarise() est appelée depuis une fonction d’un package.\n\n\n\nUn objet généralement du même type que .data.\n\nLes lignes proviennent du group_keys().\nLes colonnes sont une combinaison des clés de regroupement et des expressions récapitulatives fournient.\nLa structure de regroupement est contrôlée par l’argument .groups=, la sortie peut être un autre grouped_df , un tibble ou un jeu de données placé en rowwise()\nLes attributs du bloc de données ne sont pas conservés, car summarise() crée fondamentalement un nouveau jeu de données.\n\n\n\n\nCentre: mean(),median()\nPropagé: sd(), IQR(),mad()\nGamme: min(), max(),\nPosition: first(), last(), nth(),\nCompter: n(),n_distinct()\nLogique : any(),all()\nVariantes du back-end Le back-end du bloc de données prend en charge la création d’une variable et son utilisation dans le même résumé. Cela signifie que les variables récapitulatives créées précédemment peuvent être transformées ou combinées davantage dans le résumé, comme dans mutate(). Cependant, cela signifie également que les variables récapitulatives portant les mêmes noms que les variables précédentes les écrasent, rendant ces variables indisponibles pour les variables récapitulatives ultérieures.\nCe comportement peut ne pas être pris en charge dans d’autres backends. Pour éviter des résultats inattendus, envisagez d’utiliser de nouveaux noms pour vos variables récapitulatives, en particulier lors de la création de plusieurs résumés.\nMéthodes Cette fonction est générique , ce qui signifie que les packages peuvent fournir des implémentations (méthodes) pour d’autres classes. Consultez la documentation des méthodes individuelles pour connaître les arguments supplémentaires et les différences de comportement.\nLes méthodes suivantes sont actuellement disponibles dans les packages chargés : dbplyr ( tbl_lazy), dplyr ( data.frame, grouped_df, rowwise_df) .\nVoir également Autres verbes à table unique : arrange(), filter(), mutate(), reframe(), rename(), select(), slice()\nExemples # A summary applied to ungrouped tbl returns a single row mtcars %&gt;% summarise(mean = mean(disp), n = n()) #&gt; mean n #&gt; 1 230.7219 32"
  },
  {
    "objectID": "005_dplyr.html#cheatsheet",
    "href": "005_dplyr.html#cheatsheet",
    "title": "dplyr",
    "section": "4 Cheatsheet",
    "text": "4 Cheatsheet\nCe mot barbare est la contraction de cheat càd triche dans la langue de Molière et sheet càd feuille. Donc feuille de triche.\nCe sont des pdf en A4 recto verso qui résument et donnent une vue d’ensemble des packages de R.\nCes cheatsheets sont gérés par posit, la maison mère de RStudio. C’est une mine d’informations, de trucs et astuces.\n\nles cheatsheets de *posit* en anglais\ndes traductions en de nombreuse langues, dont le français\net des contributions bénévoles"
  },
  {
    "objectID": "005_dplyr.html#webin-r",
    "href": "005_dplyr.html#webin-r",
    "title": "dplyr",
    "section": "5 webin-R",
    "text": "5 webin-R\nJoseph LARMARANGE a réalisé un cours sur youtube consacré à dplyr"
  },
  {
    "objectID": "002_pipe.html",
    "href": "002_pipe.html",
    "title": "Le pipe",
    "section": "",
    "text": "Source\nIl est fréquent d’enchaîner des opérations en appelant successivement des fonctions sur le résultat de l’appel précédent.\nPrenons un exemple. Supposons que nous ayons un vecteur numérique v dont nous voulons calculer la moyenne puis l’afficher via un message dans la console. Pour un meilleur rendu, nous allons arrondir la moyenne à une décimale, mettre en forme le résultat à la française, c’est-à-dire avec la virgule comme séparateur des décimales, créer une phrase avec le résultat, puis l’afficher dans la console. Voici le code correspondant, étape par étape.\nv &lt;- c(1.2, 8.7, 5.6, 11.4)\nm &lt;- mean(v)\nr &lt;- round(m, digits = 1)\nf &lt;- format(r, decimal.mark = \",\")\np &lt;- paste0(\"La moyenne est de \", f, \".\")\nmessage(p)\n\nLa moyenne est de 6,7.\nCette écriture, n’est pas vraiment optimale, car cela entraîne la création d’un grand nombre de variables intermédiaires totalement inutiles. Nous pourrions dès lors imbriquer les différentes fonctions les unes dans les autres :\nmessage(paste0(\"La moyenne est de \", format(round(mean(v), digits = 1), decimal.mark = \",\"), \".\"))\n\nLa moyenne est de 6,7.\nNous obtenons bien le même résultat, mais la lecture de cette ligne de code est assez difficile et il n’est pas aisé de bien identifier à quelle fonction est rattaché chaque argument.\nUne amélioration possible serait d’effectuer des retours à la ligne avec une indentation adéquate pour rendre cela plus lisible.\nmessage(\n  paste0(\n    \"La moyenne est de \", \n    format(\n      round(\n        mean(v), \n        digits = 1), \n      decimal.mark = \",\"\n    ),\n    \".\"\n  )\n)\n\nLa moyenne est de 6,7.\nC’est déjà mieux, mais toujours pas optimal."
  },
  {
    "objectID": "002_pipe.html#le-pipe-natif-de-r",
    "href": "002_pipe.html#le-pipe-natif-de-r",
    "title": "Le pipe",
    "section": "1 Le pipe natif de R |>",
    "text": "1 Le pipe natif de R |&gt;\nDepuis la version 4.1, R a introduit ce que l’on nomme un pipe (tuyau en anglais), un nouvel opérateur noté |&gt;.\nLe principe de cet opérateur est de passer l’élément situé à sa gauche comme premier argument de la fonction située à sa droite. Ainsi, l’écriture x |&gt; f() est équivalente à f(x) et l’écriture x |&gt; f(y) à f(x, y).\nParfois, on souhaite passer l’objet x à un autre endroit de la fonction f() que le premier argument. Depuis la version 4.2, R a introduit l’opérateur _,que l’on nomme un placeholder, pour indiquer où passer l’objet de gauche. Ainsi, x |&gt; f(y, a = _) devient équivalent à f(y, a = x). ATTENTION : le placeholder doit impérativement être transmis à un argument nommé !\nTout cela semble encore un peu abstrait ? Reprenons notre exemple précédent et réécrivons le code avec le pipe.\n\nv |&gt; \n  mean() |&gt; \n  round(digits = 1) |&gt; \n  format(decimal.mark = \",\") |&gt; \n  paste0(\"La moyenne est de \", m = _, \".\")\n\n[1] \"La moyenne est de 6,7.\"\n\n\nLe code n’est-il pas plus lisible ?"
  },
  {
    "objectID": "002_pipe.html#accéder-à-un-élément-avec-purrrpluck-et-purrrchuck",
    "href": "002_pipe.html#accéder-à-un-élément-avec-purrrpluck-et-purrrchuck",
    "title": "Le pipe",
    "section": "2 Accéder à un élément avec purrr::pluck() et purrr::chuck()",
    "text": "2 Accéder à un élément avec purrr::pluck() et purrr::chuck()\nIl est fréquent d’avoir besoin d’accéder à un élément précis d’une liste, d’un tableau ou d’un vecteur, ce que l’on fait d’ordinaire avec la syntaxe [[]] ou $ pour les listes ou [] pour les vecteurs. Cependant, cette syntaxe se combine souvent mal avec un enchaînement d’opérations utilisant le pipe.\nLe package purrr, chargé par défaut avec library(tidyverse), fournit une fonction purrr::pluck() qui, est l’équivalent de [[]], et qui permet de récupérer un élément par son nom ou sa position. Ainsi, si l’on considère le tableau de données iris, pluck(iris, \"Petal.Witdh\") est équivalent à iris$Petal.Width. Voyons un exemple d’utilisation dans le cadre d’un enchaînement d’opérations.\n\nlibrary(tidyverse, quietly = TRUE)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\niris |&gt; \n  pluck(\"Petal.Width\") |&gt; \n  mean()\n\n[1] 1.199333\n\n\nÉquivalent à :\n\nmean(iris$Petal.Width)\n\n[1] 1.199333\n\n\npurrr::pluck() fonctionne également sur des vecteurs (et dans ce cas opère comme []).\n\nv &lt;- c(\"a\", \"b\", \"c\", \"d\")\nv |&gt; pluck(2)\n\n[1] \"b\"\n\n\nOn peut également, dans un même appel à purrr::pluck(), enchaîner plusieurs niveaux. Les trois syntaxes ci-après sont ainsi équivalents :\n\niris |&gt; \n  purrr::pluck(\"Sepal.Width\", 3)\n\n[1] 3.2\n\niris |&gt; \n  purrr::pluck(\"Sepal.Width\") |&gt; \n  purrr::pluck(3)\n\n[1] 3.2\n\niris[[\"Sepal.Width\"]][3]\n\n[1] 3.2\n\n\nSi l’on demande un élément qui n’existe pas, purrr:pluck() renverra l’élement vide (NULL). Si l’on souhaite plutôt que cela génère une erreur, on aura alors recours à purrr::chuck().\n\niris |&gt; pluck(\"inconnu\")\n\nNULL\n\niris |&gt; chuck(\"inconnu\")\n\nError in `chuck()`:\n! Can't find name `inconnu` in vector."
  },
  {
    "objectID": "010_combiner-variables.html",
    "href": "010_combiner-variables.html",
    "title": "Combiner des variables",
    "section": "",
    "text": "Source\nParfois, on a besoin de créer une nouvelle variable en partant des valeurs d’une ou plusieurs autres variables. Dans ce cas on peut utiliser les fonctions dplyr::if_else() pour les cas les plus simples, ou dplyr::case_when() pour les cas plus complexes.\nUne fois encore, nous utiliser le jeu de données hdv2003 pour illustrer ces différentes fonctions.\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\ndata(\"hdv2003\", package = \"questionr\")"
  },
  {
    "objectID": "010_combiner-variables.html#if_else",
    "href": "010_combiner-variables.html#if_else",
    "title": "Combiner des variables",
    "section": "1 if_else()",
    "text": "1 if_else()\ndplyr::if_else() prend trois arguments : un test, les valeurs à renvoyer si le test est vrai, et les valeurs à renvoyer si le test est faux.\nVoici un exemple simple :\n\nv &lt;- c(12, 14, 8, 16)\nif_else(v &gt; 10, \"supérieur à 10\", \"inférieur à 10\")\n\n[1] \"supérieur à 10\" \"supérieur à 10\" \"inférieur à 10\" \"supérieur à 10\"\n\n\nLa fonction devient plus intéressante avec des tests combinant plusieurs variables. Par exemple, imaginons qu’on souhaite créer une nouvelle variable indiquant les hommes de plus de 60 ans :\n\nhdv2003 &lt;- \n  hdv2003 |&gt; \n  mutate(\n    statut = if_else(\n      sexe == \"Homme\" & age &gt; 60,\n      \"Homme de plus de 60 ans\",\n      \"Autre\"\n    )\n  )\nhdv2003 |&gt; \n  pull(statut) |&gt; \n  questionr::freq()\n\n                           n    % val%\nAutre                   1778 88.9 88.9\nHomme de plus de 60 ans  222 11.1 11.1\n\n\nIl est possible d’utiliser des variables ou des combinaisons de variables au sein du dplyr::if_else(). Supposons une petite enquête menée auprès de femmes et d’hommes. Le questionnaire comportait une question de préférence posée différemment aux femmes et aux hommes et dont les réponses ont ainsi été collectées dans deux variables différentes, pref_f et pref_h, que l’on souhaite combiner en une seule variable. De même, une certaine mesure quantitative a été réalisée, mais une correction est nécessaire pour normaliser ce score (retirer 0.4 aux scores des hommes et 0.6 aux scores des femmes). Cela peut être réalisé avec le code ci-dessous.\n\ndf &lt;- tibble(\n  sexe = c(\"f\", \"f\", \"h\", \"h\"),\n  pref_f = c(\"a\", \"b\", NA, NA),\n  pref_h = c(NA, NA, \"c\", \"d\"),\n  mesure = c(1.2, 4.1, 3.8, 2.7)\n)\ndf\n\n# A tibble: 4 × 4\n  sexe  pref_f pref_h mesure\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt;\n1 f     a      &lt;NA&gt;      1.2\n2 f     b      &lt;NA&gt;      4.1\n3 h     &lt;NA&gt;   c         3.8\n4 h     &lt;NA&gt;   d         2.7\n\n\n\ndf &lt;- \n  df |&gt; \n  mutate(\n    pref = if_else(sexe == \"f\", pref_f, pref_h),\n    indicateur = if_else(sexe == \"h\", mesure - 0.4, mesure - 0.6)\n  )\ndf\n\n# A tibble: 4 × 6\n  sexe  pref_f pref_h mesure pref  indicateur\n  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt;\n1 f     a      &lt;NA&gt;      1.2 a            0.6\n2 f     b      &lt;NA&gt;      4.1 b            3.5\n3 h     &lt;NA&gt;   c         3.8 c            3.4\n4 h     &lt;NA&gt;   d         2.7 d            2.3"
  },
  {
    "objectID": "010_combiner-variables.html#case_when",
    "href": "010_combiner-variables.html#case_when",
    "title": "Combiner des variables",
    "section": "2 case_when()",
    "text": "2 case_when()\ndplyr::case_when() est une généralisation de dplyr::if_else() qui permet d’indiquer plusieurs tests et leurs valeurs associées.\nImaginons que l’on souhaite créer une nouvelle variable permettant d’identifier les hommes de plus de 60 ans, les femmes de plus de 60 ans, et les autres. On peut utiliser la syntaxe suivante :\n\nhdv2003 &lt;-\n  hdv2003 |&gt; \n  mutate(\n    statut = case_when(\n      age &gt;= 60 & sexe == \"Homme\" ~ \"Homme, 60 et plus\",\n      age &gt;= 60 & sexe == \"Femme\" ~ \"Femme, 60 et plus\",\n      TRUE ~ \"Autre\"\n    )\n  )\nhdv2003 |&gt; \n  pull(statut) |&gt; \n  questionr::freq()\n\n                     n    % val%\nAutre             1484 74.2 74.2\nFemme, 60 et plus  278 13.9 13.9\nHomme, 60 et plus  238 11.9 11.9\n\n\ndplyr::case_when() prend en arguments une série d’instructions sous la forme condition ~ valeur. Il les exécute une par une, et dès qu’une condition est vraie, il renvoi la valeur associée.\nLa clause TRUE ~ \"Autre\" permet d’assigner une valeur à toutes les lignes pour lesquelles aucune des conditions précédentes n’est vraie."
  },
  {
    "objectID": "010_combiner-variables.html#recode_if",
    "href": "010_combiner-variables.html#recode_if",
    "title": "Combiner des variables",
    "section": "3 recode_if()",
    "text": "3 recode_if()\nParfois, on n’a besoin de ne modifier une variable que pour certaines observations. Prenons un petit exemple :\n\ndf &lt;- tibble(\n  pref = factor(c(\"bleu\", \"rouge\", \"autre\", \"rouge\", \"autre\")),\n  autre_details = c(NA, NA, \"bleu ciel\", NA, \"jaune\")\n)\ndf\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 bleu  &lt;NA&gt;         \n2 rouge &lt;NA&gt;         \n3 autre bleu ciel    \n4 rouge &lt;NA&gt;         \n5 autre jaune        \n\n\nNous avons demandé aux enquêtés d’indiquer leur couleur préférée. Ils pouvaient répondre bleu ou rouge et avait également la possibilité de choisir autre et d’indiquer la valeur de leur choix dans un champs textuel libre.\nUne des personnes enquêtées a choisi autre et a indiqué dans le champs texte la valeur bleu ciel. Pour les besoins de l’analyse, on peut considérer que cette valeur bleu ciel pour être tout simplement recodée en bleu.\nEn syntaxe R classique, on pourra simplement faire :\n\ndf$pref[df$autre_details == \"bleu ciel\"] &lt;- \"bleu\"\ndf\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 bleu  &lt;NA&gt;         \n2 rouge &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 rouge &lt;NA&gt;         \n5 autre jaune        \n\n\nAvec dplyr::if_else(), on serait tenté d’écrire :\n\ndf |&gt; \n  mutate(pref = if_else(autre_details == \"bleu ciel\", \"bleu\", pref))\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;chr&gt; &lt;chr&gt;        \n1 &lt;NA&gt;  &lt;NA&gt;         \n2 &lt;NA&gt;  &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 &lt;NA&gt;  &lt;NA&gt;         \n5 autre jaune        \n\n\nOn obtient une erreur, car dplyr::if_else() exige les valeurs fournie pour true et false soient de même type. Essayons alors :\n\ndf |&gt; \n  mutate(pref = if_else(autre_details == \"bleu ciel\", factor(\"bleu\"), pref))\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 &lt;NA&gt;  &lt;NA&gt;         \n2 &lt;NA&gt;  &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 &lt;NA&gt;  &lt;NA&gt;         \n5 autre jaune        \n\n\nPour obtenir le bon résultat, il faudrait inverser la condition :\n\ndf |&gt; \n  mutate(pref = if_else(\n    autre_details != \"bleu ciel\", \n    pref, \n    factor(\"bleu\")\n  ))\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 &lt;NA&gt;  &lt;NA&gt;         \n2 &lt;NA&gt;  &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 &lt;NA&gt;  &lt;NA&gt;         \n5 autre jaune        \n\n\nMais ce n’est toujours pas suffisant. En effet, la variable autre_details a des valeurs manquantes pour lesquelles le test autre_details != \"bleu ciel\" renvoie NA ce qui une fois encore génère des valeurs manquantes non souhaitées. Dès lors, il nous faut soit définir l’argument missing de dplyr::if_else(), soit être plus précis dans notre test.\n\ndf |&gt; \n  mutate(pref = if_else(\n    autre_details != \"bleu ciel\", \n    pref, \n    factor(\"bleu\"),\n    missing = pref\n  ))\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 bleu  &lt;NA&gt;         \n2 rouge &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 rouge &lt;NA&gt;         \n5 autre jaune        \n\n\n\ndf |&gt; \n  mutate(pref = if_else(\n    autre_details != \"bleu ciel\" | is.na(autre_details), \n    pref, \n    factor(\"bleu\")\n  ))\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 bleu  &lt;NA&gt;         \n2 rouge &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 rouge &lt;NA&gt;         \n5 autre jaune        \n\n\nBref, on peut s’en sortir avec dplyr::if_else() mais ce n’est pas forcément le plus pratique dans le cas présent. La syntaxe en base R fonctionne très bien, mais ne peut pas être intégrée à un enchaînement d’opérations utilisant le pipe.\nDans ce genre de situation, on pourra être intéressé par la fonction labelled::recode_if() disponible dans le package labelled. Elle permet de ne modifier que certaines observations d’un vecteur en fonction d’une condition. Si la condition vaut FALSE ou NA, les observations concernées restent inchangées. Voyons comment cela s’écrit :\n\ndf &lt;-\n  df |&gt; \n  mutate(\n    pref = pref |&gt; \n      labelled::recode_if(autre_details == \"bleu ciel\", \"bleu\")\n  )\ndf\n\n# A tibble: 5 × 2\n  pref  autre_details\n  &lt;fct&gt; &lt;chr&gt;        \n1 bleu  &lt;NA&gt;         \n2 rouge &lt;NA&gt;         \n3 bleu  bleu ciel    \n4 rouge &lt;NA&gt;         \n5 autre jaune        \n\n\nC’est tout de suite plus intuitif !"
  },
  {
    "objectID": "020_graphiques-ggplot2.html",
    "href": "020_graphiques-ggplot2.html",
    "title": "Graphiques avec ggplot2",
    "section": "",
    "text": "Source\nLe package ggplot2 fait partie intégrante du tidyverse. Développé par Hadley Wickham, ce package met en œuvre la grammaire graphique théorisée par Leland Wilkinson. Il devient vite indispensable lorsque l’on souhaite réaliser des graphiques un peu complexe."
  },
  {
    "objectID": "020_graphiques-ggplot2.html#ressources",
    "href": "020_graphiques-ggplot2.html#ressources",
    "title": "Graphiques avec ggplot2",
    "section": "1 Ressources",
    "text": "1 Ressources\nIl existe de très nombreuses ressources traitant de ggplot2.\nPour une introduction en français, on pourra se référer au chapitre Visualiser avec ggplot2 de l’Introduction à R et au tidyverse de Julien Barnier, au chapitre Introduction à ggplot2, la grammaire des graphiques du site analyse-R et adapté d’une séance de cours de François Briatte, ou encore au chapitre Graphiques du cours Logiciel R et programmation d’Ewen Gallic.\nPour les anglophones, la référence reste encore l’ouvrage ggplot2: Elegant Graphics for Data Analysis d’Hadley Wickham lui-même, dont la troisième édition est librement accessible en ligne (https://ggplot2-book.org/). D’un point de vue pratique, l’ouvrage R Graphics Cookbook: practical recipes for visualizing data de Winston Chang est une mine d’informations, ouvrage là encore librement accessible en ligne (https://r-graphics.org/)."
  },
  {
    "objectID": "020_graphiques-ggplot2.html#les-bases",
    "href": "020_graphiques-ggplot2.html#les-bases",
    "title": "Graphiques avec ggplot2",
    "section": "2 Les bases",
    "text": "2 Les bases\nggplot2 nécessite que les données du graphique soient sous la forme d’un tableau de données (data.frame ou tibble) au format tidy, c’est-à-dire avec une ligne par observation et les différentes valeurs à représenter sous forme de variables du tableau.\nTous les graphiques avec ggplot2 suivent une même logique. En premier lieu, on appellera la fonction ggplot2::ggplot() en lui passant en paramètre le fichier de données.\nggplot2 nomme esthétiques les différentes propriétés visuelles d’un graphique, à savoir l’axe des x (x), celui des y (y), la couleur des lignes (colour), celle de remplissage des polygones (fill), le type de lignes (linetype), la forme des points (shape), etc. Une représentation graphique consiste donc à représenter chacune de nos variables d’intérêt selon une esthétique donnée. En second lieu, on appellera donc la fonction ggplot2::aes() pour indiquer la correspondance entre les variables de notre fichier de données et les esthétiques du graphique.\nA minima, il est nécessaire d’indiquer en troisième lieu une géométrie, autrement dit la manière dont les éléments seront représentés visuellement. À chaque géométrie corresponds une fonction commençant par geom_, par exemple ggplot2::geom_point() pour dessiner des points, ggplot2::geom_line() pour des lignes, ggplot2::geom_bar() pour des barres ou encore ggplot2::geom_area() pour des aires. Il existe de nombreuses géométries différentes, chacune prenant en compte certaines esthétiques, certaines étant requises pour cette géométrie et d’autres optionnelles. La liste des esthétiques prises en compte par chaque géométrie est indiquée dans l’aide en ligne de cette dernière.\nOn trouvera une liste des géométries dans la cheat sheet de ggplot2.\nVoici un exemple minimal de graphique avec ggplot2 :\n\nlibrary(ggplot2)\np &lt;- \n  ggplot(iris) +\n  aes(\n    x = Petal.Length, \n    y = Petal.Width, \n    colour = Species\n  ) +\n  geom_point()\np\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntaxe additive\n\n\n\nLe développement de ggplot2 a débuté avant celui du tidyverse et la généralisation du pipe. Dès lors, on ne sera pas étonné que la syntaxe de ggplot2 n’ait pas recours à ce dernier mais repose sur une approche additive. Un graphique est dès lors initialisé avec la fonction ggplot2::ggplot() et l’on ajoutera successivement des éléments au graphique en appelant différentes fonctions et en utilisant l’opérateur +.\n\n\nIl est ensuite possible de personnaliser de nombreux éléments d’un graphique et notamment :\n\nles étiquettes ou labs (titre, axes, légendes) avec ggplot2::ggtitle(), ggplot2::xlab(), ggplot2::ylab() ou encore la fonction plus générique ggplot2::labs() ;\nles échelles (scales) des différentes esthétiques avec les fonctions commençant par scale_ ;\nle système de coordonnées avec les fonctions commençant par coord_ ;\nles facettes (facets) avec les fonctions commençant par facet_ ;\nla légende (guides) avec les fonctions commençant par guide_ ;\nle thème du graphiques (mise en forme des différents éléments) avec ggplot2::theme().\n\np +\n  labs(\n    x = \"Longueur du pétale\",\n    y = \"Largeur du pétale\",\n    colour = \"Espèce\"\n  ) +\n  ggtitle(\n    \"Relation entre longueur et largeur des pétales\",\n    subtitle = \"Jeu de données Iris\"\n  ) +\n  scale_x_continuous(breaks = 1:7) +\n  scale_y_continuous(\n    labels = scales::label_number(decimal.mark = \",\")\n  ) +\n  coord_equal() +\n  facet_grid(cols = vars(Species)) +\n  guides(\n    color = guide_legend(nrow = 2)\n  ) +\n  theme_light() +\n  theme(\n    legend.position = \"bottom\",\n    axis.title = element_text(face = \"bold\")\n  )"
  },
  {
    "objectID": "020_graphiques-ggplot2.html#combiner-plusieurs-graphiques",
    "href": "020_graphiques-ggplot2.html#combiner-plusieurs-graphiques",
    "title": "Graphiques avec ggplot2",
    "section": "3 Combiner plusieurs graphiques",
    "text": "3 Combiner plusieurs graphiques\nPlusieurs packages proposent des fonctions pour combiner ensemble des graphiques ggplot2, comme patchwork, ggpubr, {egg} ou cowplot. Ici, nous privilégierons le package patchwork car, bien qu’il ne fasse pas partie du tidyverse, est développé et maintenant par les mêmes auteurs que ggplot2.\nCommençons par créer quelques graphiques avec ggplot2.\n\np1 &lt;- ggplot(mtcars) +\n  aes(x = wt, y = mpg) + \n  geom_point()\np2 &lt;- ggplot(mtcars) +\n  aes(x = factor(cyl)) +\n  geom_bar()\np3 &lt;- ggplot(mtcars) +\n  aes(x = factor(cyl), y = mpg) +\n  geom_violin() +\n  theme(axis.title = element_text(size = 20))\np4 &lt;- ggplot(mtcars) +\n  aes(x = factor(cyl), y = mpg) + \n  geom_boxplot() +\n  ylab(NULL)\n\n\n3.1 patchwork\nLe symbole + permet de combiner des graphiques entre eux. Le package patchwork déterminera le nombre de lignes et de colonnes en fonction du nombre de graphiques. On pourra noter que les axes des graphiques sont alignés les uns par rapports aux autres.\n\nlibrary(patchwork)\np1 + p2 + p3 + p4\n\n\n\n\n\n\n\n\nLes symboles | et / permettent d’indiquer une disposition côte à côte ou les uns au-dessus des autres.\n\np1 | p2 / p3\n\n\n\n\n\n\n\n\nOn peut utiliser les parenthèses pour indiquer des arrangements plus complexes.\n\n(p1 + p2) / p3\n\n\n\n\n\n\n\n\n\n(p1 + p2) | p3\n\n\n\n\n\n\n\n\n\nlist(p1, p2, p3, p4) |&gt; \n  wrap_plots()\n\n\n\n\n\n\n\n\nLa fonction patchwork::plot_layout() permet de contrôler les hauteurs / largeurs relatives des lignes / colonnes.\n\np1 + p2 + p3 + p4 + plot_layout(widths = c(2, 1))\n\n\n\n\n\n\n\n\nOn peut également ajouter un titre ou des étiquettes avec patchwork::plot_annotation().\n\np1 + p2 + p3 + p4 +\n  plot_annotation(\n    title = \"Titre du graphique\",\n    subtitle = \"sous-titre\",\n    caption = \"notes additionelles\",\n    tag_levels = \"a\",\n    tag_suffix = \".\"\n  )"
  }
]